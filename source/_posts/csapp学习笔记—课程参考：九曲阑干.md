---
title: csapp学习笔记—课程参考：九曲阑干
date: 2023-04-23 11:17:03
tags:
---

# 全书概述

1. 第一章 ：计算机系统漫游，用一个简单的helloworld程序从开始到结束的一生来介绍计算机系统的主要概念。
2. 第二到六章：程序结构和执行
3. 第七到九章：应用程序在计算机系统上运行的相关知识
4. 第九章到最后：程序间的交互和通信

<!-- more -->

# 计算机系统漫游

## 漫游（一）

### Hello 程序

```c
#include <stdio.h>
int main()
{
    printf("hello,world\n");
    return 0;
}
```

保存得到一个后缀为.c的文件--hello.c

### 编译系统

```sh
linux> gcc -o hello hello.c
```

![](https://raw.githubusercontent.com/marcaas/hexoPicgo/master/20230423131251.png)


通过编译器gcc对hello.c进行处理,生成可执行文件--hello, 此过程虽然是通过一条指令实现的, 但是整个编译过程却是十分复杂的, 大致可以分为四个阶段, 分别为预处理、编译、汇编以及链接

![](https://raw.githubusercontent.com/marcaas/hexoPicgo/master/20230423131602.png)

#### 预处理

预处理器会读取hello.c文件中头文件的内容，如

```c
#include <stdio.h>
```

并将其中的内容直接插入到源程序中，结果就得到了另一个c程序，这个经过预处理器处理后得到的文件通常以.i结尾

![](https://raw.githubusercontent.com/marcaas/hexoPicgo/master/20230423132059.png)

#### 编译

编译器将hello.i文件翻译为hello.s文件，此过程被称为编译，其中编译这一阶段包括词法分析、语法分析、语义分析、中间代码生成以及优化等等一系列的中间操作。

![](https://raw.githubusercontent.com/marcaas/hexoPicgo/master/20230423132539.png)

#### 汇编

汇编器根据指令集将汇编程序hello.s翻译成机器指令，并且把这一系列的机器指令按照固定的规则进行打包，得到可重定位目标文件--hello.o

![](https://raw.githubusercontent.com/marcaas/hexoPicgo/master/20230423132807.png)

此时hello.o虽然是一个二进制文件，但是还不能执行，还要经历最后一个阶段--链接

#### 链接

在hello这个程序中，我们调用了printf函数，这个函数是标准C库中的一个函数，每一个C语言的编译器都会提供，通俗点讲，就是当你要调用printf这个函数时，编译器就知道你要在屏幕上打印输出内容，它会将这行代码翻译成计算机可以理解的指令，这个printf函数在名为printf.o的文件中，它是一个提前编译好的目标文件，链接器（ld）负责把hello.o和printf.o进行合并，当然这个合并需要遵守一些规则，正是因为连接器要对hello.o和printf.o进行调整，所以hello.o才会被称为可重定位目标文件，最终经过链接阶段可以得到可执行目标文件--hello，此时得到的hello就可以被加载到内存中执行了

![](https://raw.githubusercontent.com/marcaas/hexoPicgo/master/20230423133512.png)

上述就是编译系统的一个简单概述

### 为什么要理解编译系统如何工作

1. 理解编译系统可以优化程序的性能，现代编译器是非常成熟的工具，通常可以生成很好的代码，我们没有必要为了写出高效的代码而去研究编译器的内部是如何工作的，但是还是需要对机器执行的代码有一个基本的了解，这样我们就知道编译器把不同的C代码转换成的机器代码是什么
2. 理解编译系统可以帮助我们理解链接过程中出现的错误，如果所有的程序都像helloworld一样简单那的确没有必要去理解编译系统，但当你开始构造大型程序时，往往涉及各种函数库的调用，根据以往的经验，一些奇奇怪怪的错误往往都是与链接器有关的，例如：静态变量和全局变量的区别是什么？静态库和动态库的区别是什么？更严重的是，还有一些错误直到程序运行的时候才会出现
3. 避免安全漏洞，多年以来，缓冲区溢出是导致互联网安全漏洞的主要原因，如何避免写出的代码存在安全漏洞，第一步就是要理解数据和控制信息在程序栈上是如何存储的，了解不严谨不规范的书写方式会引起什么样的后果，在第三章中，会讲述堆栈的原理和缓冲区溢出错误，以及如何利用操作系统、编译器来降低攻击的风险

## 漫游（二）

### 通过shell运行hello程序

通过上一小节的内容，我们已经将生成的可执行目标文件放在系统的磁盘上

![](https://raw.githubusercontent.com/marcaas/hexoPicgo/master/20230423135154.png)

为了在linux系统上运行可执行程序，第一步我们需要打开一个shell程序，然后在shell程序中输入相应可执行文件的文件名

```sh
linux> ./hello
```

不了解linux系统的同学可能对shell比较陌生，这里做一个简单的介绍，shell是一个命令解释程序，它输出一个提示符 > 来等待一个命令行的输入，然后执行这个命令，如果该命令行的第一个单词不是内置的shell命令，那么shell就会假设这是一个可执行文件的名字 ，对这个文件进行加载并运行。在第八章的课程中，我们将通过一个实验来讲述如何实现一个简单的shell程序

接下来我们来看一下hello程序运行时，系统发生了什么，不过在此之前我们先来看一下计算机系统的硬件组成

### 计算机系统的硬件组成

#### 中央处理单元（CPU），也称处理器

实际上CPU的内部结构是非常复杂的，此处为了介绍hello程序的运行，我们采用简化的框图来大概示意一下整个CPU的结构

##### 程序计数器（Program Count，PC）

![](https://raw.githubusercontent.com/marcaas/hexoPicgo/master/20230423140420.png)

PC实质上是一个大小为一个字的存储区域（对于32位的机器，一个字是4字节，对于64位的机器，一个字是8个字节），说白了PC就是一个4字节或者8字节的存储空间，里面存放的是某一条指令的地址，从处理器上电的一瞬间到断电的那一瞬间，处理器就在不断地执行PC指向的指令，然后更新PC，使其指向下一条要执行的指令（注意：这个下一条指令与刚刚执行的指令不一定是相邻的）

##### 寄存器文件（Register file）

![](https://raw.githubusercontent.com/marcaas/hexoPicgo/master/20230423140917.png)

他就是CPU内部的一个存储设备，寄存器文件是由一些单字长的寄存器构成的，每个寄存器都有自己唯一的名字，通俗点讲，寄存器可以理解为一个临时存放数据的空间

##### 算术逻辑单元（ALU）

![](https://raw.githubusercontent.com/marcaas/hexoPicgo/master/20230423141401.png)

ALU是算术逻辑单元的简称，是能实现多组算术运算和逻辑运算的组合逻辑电路，是中央处理器(CPU)的执行单元，也是所有中央处理器的核心组成部分。ALU的输入是要进行操作的数据（称为操作数）以及来自控制单元的指令代码，用来指示进行哪种运算。它的输出即为运算结果。

#### 主存（也称为内存）

![](https://raw.githubusercontent.com/marcaas/hexoPicgo/master/20230423141816.png)

处理器在执行程序时，内存主要存放程序的指令以及数据，从物理上讲，内存是由随机动态存储器芯片组成，从逻辑上讲，内存可以看成一个从零开始的大数组，每个字节都有相应的地址，关于内存更多的内容，在第六章中有详细的讲解

#### 总线

![](https://raw.githubusercontent.com/marcaas/hexoPicgo/master/20230423142138.png)

内存和处理器之间通过总线来进行数据传递，实际上总线贯穿了整个计算机系统它负责将信息从一个部件传递到另外一个部件，通常总线被设计成传送固定长度的字节快，也就是字（word），这个字到底是多少个字节，各个系统中是不一样的

#### 各种输入输出设备

例如，键盘、鼠标、显示器以及磁盘等等，每一个输入输出设备都通过一个控制器或者适配器与IO总线相连控制器与适配器主要区别在于它们的封装方式，无论是控制器还是适配器，它们的功能都是在IO设备与IO总线之间传递数据，更多IO的知识，将在第6章和第10章进行详细的讲解

### hello程序的执行

首先，我们通过键盘输入 "./hello" 的字符串，shell程序会将输入的字符逐一读入寄存器，处理器会把hello这个字符串放入内存中，整个流程如下图所示

![](https://raw.githubusercontent.com/marcaas/hexoPicgo/master/20230423145141.png)

当我们完成输入按下回车键时，shell程序就知道我们已经完成了命令的输入，然后执行一系列的指令来加载可执行文件hello，这些指令将hello中的数据和代码从磁盘复制到内存，数据就是我们要显示输出的 "hello,world\n" ，这个复制过程将利用DMA（Direct Memory Access）技术，数据可以不经过处理器，从磁盘直接到达内存

![](https://raw.githubusercontent.com/marcaas/hexoPicgo/master/20230423145639.png)

当可执行文件hello中的代码和数据被加载到内存中，处理器就开始执行main函数中的代码，CPU会将 "hello,world\n" 这个字符串从内存复制到寄存器文件，然后再从寄存器文件复制到显示设备，最终hello, world显示在屏幕上

![](https://raw.githubusercontent.com/marcaas/hexoPicgo/master/20230423145852.png)

从hello程序的执行过程我们可以看出，系统就算执行如此简单的程序，数据信息仍旧需要在磁盘、内存、处理器以及IO设备之间进行搬运，数据从一个地方搬运到另一个地方需要花费时间，系统设计人员的一个主要任务就是缩短信息搬运所花费的时间

通常情况下大容量的存储设备的存取速度要比小容量的慢，运行速度更快的设备的价格比低速设备更贵

### 计算机系统的信息存储层次结构

![](https://raw.githubusercontent.com/marcaas/hexoPicgo/master/20230423155427.png)

从这个层次结构来看，从上到下，设备的访问速度越来越慢，容量越来越大，每字节的造价也越来越便宜，这个存储层次的主要思想，就是上一层存储设备是下一层存储设备的高速缓存，关于缓存的更多内容将在第六章会有更加详细的讲解
